from collections import defaultdict
from random import uniform
from graph import Graph
import timeit
from flask import Flask, jsonify
from datetime import date, timedelta, datetime


def printListOfDates():
	d1 = date(2017, 1, 1)  # start date
	d2 = date(2017, 12, 31)  # end date
	delta = d2 - d1         # timedelta
	listDates=[]
	for i in range(delta.days + 1):
		listDates.append(d1 + timedelta(days=i))
	return listDates


def find_all_paths2(graph, start, end, path=[]):
        path = path + [start]
        if start == end:
            return [path]
        if start not in graph:
        	return []
        paths = []
        for node in graph[start]:
            if node not in path:
                newpaths = find_all_paths2(graph, node, end, path)
                for newpath in newpaths:
                	#print("test",newpath)
                	if len(newpath) == len(graph):
                		paths.append(newpath)

        return paths

def permutationsFromOrigin(array):
	for i in range(1,len(array)):
		yield array[0],array[i]

def permutationsReturnOrigin(array):
	for i in range(1, len(array)):
		yield array[i-1],array[i]
	yield array[len(array)-1],array[0]

def transformArray(routes):
	""" 
	take in argument routes and return it in a better format 
	time : 0.004s
	"""
	array=[]
	routes_elements = routes
	for couple in routes_elements:
		array.append(couple[0]+ "-" +couple[1])

	return array

#WHAT WE HAVE IN DATABASE (prices)
def createFakePriceDatabase(routes):
	"""
	take in argument the routes generated by the device with the ryanair database of airports routes and return a fake database of prices 
	time : 1.7s
	"""

	transformedArray = transformArray(routes)
	priceDatabase = {key:[int(round(uniform(20, 180))) for _ in range(364)] for key in transformedArray}

	return priceDatabase

# GENERATED WITH USER INPUTS
def createOptimizedGraph(routes):
	""" 
	take the routes user inputs generated by sql and return an optimized graph
	time : 0.007s
	"""

	graphClass = Graph(routes, directed=True)

	return graphClass.getGraph()

def optimizedRoutePossibilities2(routes,cities):
	""" 
	take in argument routes and return all the paths via dfs
	time : 0.16s
	"""
	graph = createOptimizedGraph(routes)
	for couple in permutationsFromOrigin(cities):
		if couple is not None:
			#yield find_all_paths2(graph,couple[0],couple[1])[0]
			path = find_all_paths2(graph,couple[0],couple[1])[0]
			if couple[0] in graph[path[-1]]:
				yield path


def finalResult(routes,startDate,cities,days):
	""" 
	take in argument routes and return all the paths via dfs
	time : 0.16s
	"""

	calendar = printListOfDates()
	indexStartDate = calendar.index(startDate)
	priceDatabase = createFakePriceDatabase(routes)
	sumPricesArray = []
	globalPrices = []
	jsonPrices = []
	details = []
	couples = []
	possibility_array = []
	for possibility in optimizedRoutePossibilities2(routes,cities):
		i=0
		prices=[]
		possibility_array +=[possibility]
		#print(possibility)
		for couple in permutationsReturnOrigin(possibility):
			#print(couple)
			couple_name = couple
			couples.append(couple_name)
			#print(priceDatabase[couple[0]+"-"+couple[1]])
			priceForDate = priceDatabase[couple[0]+"-"+couple[1]][indexStartDate + i]
			#print(priceForDate)
			
			prices += [priceForDate]
			i+=1
		#print(prices)
		globalPrices += [prices]
		sumPrices = sum(prices)
		#print(sumPrices)
		sumPricesArray+=[sumPrices]
		

	#print(sumPricesArray)
	#print(min(sumPricesArray))
	#print(globalPrices)
	len_sum = len(sumPricesArray)
	for i in range(len_sum):
		if sumPricesArray[i] == min(sumPricesArray):
			bestPosibility = possibility_array[i]
			jsonPrices = globalPrices[i]
			#print(jsonPrices)

	for i in range(len(jsonPrices)):
		item = {"title": couples[i],"price":jsonPrices[i]}
		details.append(item)

	
	
	#print(details)


	route = [
		{"title":bestPosibility,
		"price": min(sumPricesArray)
		}
	]
	#print(route)

	return jsonify(details,route)
	


#print(finalResult(routes,startDate,cities,days))

## TIME FUCTIONS
# def wrapper(func, *args, **kwargs):
#  	def wrapped():
#  		return func(*args, **kwargs)
#  	return wrapped

# #wrapped = wrapper(transformArray, routes)
# wrapped = wrapper(optimizedRoutePossibilities, routes,cities)
# #wrapped = wrapper(createOptimizedGraph, routes)

# print(timeit.timeit(wrapped, number=1000))




